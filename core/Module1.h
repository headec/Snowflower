///////////////////////////////////////////////////////////////////////////////
// Module1.h
#pragma once

#include "SnowflowerInterfaces.h"

#include <vector>
#include <unordered_map>

#include "elmopp.h"
#include "manager.h"

#include "net/service.h"
#include "net/protocol.h"
#include "net/define.h"

class CModule1 
	: public ITComObject
	, public ITcADI
	, public ITcWatchSource
///<AutoGeneratedContent id="InheritanceList">
	, public ITcCyclic
///</AutoGeneratedContent>
{
public:
	DECLARE_IUNKNOWN()
	DECLARE_IPERSIST(CID_SnowflowerCModule1)
	DECLARE_ITCOMOBJECT_LOCKOP()
	DECLARE_ITCADI()
	DECLARE_ITCWATCHSOURCE()
	DECLARE_OBJPARAWATCH_MAP()
	DECLARE_OBJDATAAREA_MAP()

	CModule1();
	virtual	~CModule1();

	using state = void(CModule1::*)();

///<AutoGeneratedContent id="InterfaceMembers">
	// ITcCyclic
	virtual HRESULT TCOMAPI CycleUpdate(ITcTask* ipTask, ITcUnknown* ipCaller, ULONG_PTR context);

///</AutoGeneratedContent>
	/* APIs starts */
	void transit(protocol::state_t state) {
		m_pPrevState = m_pCurrState;
		m_pCurrState = m_mapState[state];
		m_State = static_cast<char>(state);
	}

	void run() {
		if (m_pCurrState) {
			(this->*m_pCurrState)();
		}
		m_Event = static_cast<char>(protocol::btn_t::none);
	}

	bool isDeviceOn() const {
		return static_cast<bool>(m_Inputs.WcState) == 0;
	}

	bool isEvent(protocol::btn_t e) const {
		return m_Event == static_cast<uint8_t>(e);

	bool once() const {
		return m_pCurrState != m_pPrevState;
	}

	bool timeout(USHORT& t, const unsigned int count) const {
		return ((++t %= count + 1) == 0);
	}

	protocol::move_t receivedMove() const {
		return{ m_Move.Immediate, m_Move.Position };
	}
	/* APIs ends */

	/* States starts */
	void disconnected();
	void init();
	void idle();
	void ready();
	void active();
	void emergency();
	void recovery();
	void error();
	/* States ends */
protected:
	DECLARE_ITCOMOBJECT_SETSTATE();

	HRESULT AddModuleToCaller();
	VOID RemoveModuleFromCaller();

	// Tracing
	CTcTrace m_Trace;
	
///<AutoGeneratedContent id="Members">
	TcTraceLevel m_TraceLevelMax;
	char m_State;
	Module1Setting m_Setting;
	Module1Move m_Move;
	char m_Event;
	Module1Inputs m_Inputs;
	Module1Outputs m_Outputs;
	ITcCyclicCallerInfoPtr m_spCyclicCaller;
///</AutoGeneratedContent>

	// TODO: Custom variable
	state m_pCurrState;
	state m_pPrevState;
	std::unordered_map<protocol::state_t, state> m_mapState;

	slv::elmopp elmo_[12];
	manager<slv::elmopp> elmos_;
	protocol::rpc::service mainService_;

	// Due to TwinCAT constraints
	std::unordered_set<int> bending = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
	std::unordered_set<int> translation = { 11 };
};
